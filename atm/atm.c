#include "atm.h"
#include "ports.h"
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <openssl/conf.h>
#include <openssl/evp.h>
#include <openssl/err.h>
#include <openssl/ssl.h>

/* on atm create need to initialize key and IV
 * these should be randomly generated by init 
 * so that they can be shared with the bank*/
void atm_read_file(ATM *atm, char*atm_str);
char key[32]; 
char *iv[16]; 
char *currSyncKey;  
int loggedOn = 0;
int failedAttempts = 0;


ATM* atm_create(char *atm_path) {
	printf("%s", "This works0"); 
    ATM *atm = (ATM*) malloc(sizeof(ATM));
    if(atm == NULL) {
        perror("Could not allocate ATM");
        exit(1);
    }

    // Set up the network state
    atm->sockfd=socket(AF_INET,SOCK_DGRAM,0);

    bzero(&atm->rtr_addr,sizeof(atm->rtr_addr));
    atm->rtr_addr.sin_family = AF_INET;
    atm->rtr_addr.sin_addr.s_addr=inet_addr("127.0.0.1");
    atm->rtr_addr.sin_port=htons(ROUTER_PORT);

    bzero(&atm->atm_addr, sizeof(atm->atm_addr));
    atm->atm_addr.sin_family = AF_INET;
    atm->atm_addr.sin_addr.s_addr=inet_addr("127.0.0.1");
    atm->atm_addr.sin_port = htons(ATM_PORT);
    bind(atm->sockfd,(struct sockaddr *)&atm->atm_addr,sizeof(atm->atm_addr));

    // Set up the protocol state
    // TODO set up more, as needed
	//currSyncKey = initSyncKey; 
	atm_read_file(atm, atm_path); 
    return atm;
}

void atm_read_file(ATM *atm, char *atm_str) {
	printf("%s", "Before everything. We're here. We're trying to read file"); 
    FILE *fp = fopen(atm_str, "r");
    if (fp == NULL) {
        printf("%s", "Error opening atm initialization file\n"); 
        exit(64); 
    }
	// extra eats the newLine chars 
	char extra[1]; 
	fgets(key, 32, fp);
	fgets(extra, 1, fp);
    fgets(key, 16, fp); 
	fgets(extra, 1, fp);
	fgets(key, 10, fp); 
	printf("%s", "This works\n"); 
    fclose(fp);
}

void atm_free(ATM *atm) {
    if(atm != NULL) {
        close(atm->sockfd);
        free(atm);
    }
}

ssize_t atm_send(ATM *atm, char *data, size_t data_len) {
    // Returns the number of bytes sent; negative on error
    return sendto(atm->sockfd, data, data_len, 0,
                  (struct sockaddr*) &atm->rtr_addr, sizeof(atm->rtr_addr));
}

ssize_t atm_recv(ATM *atm, char *data, size_t max_data_len) {
    // Returns the number of bytes received; negative on error
    return recvfrom(atm->sockfd, data, max_data_len, 0, NULL, NULL);
}


// Method added by Josh for processing begin session command


void createAuth(unsigned char* newAuth) {
	int i; 
	srand(time(NULL)); 
		for(i = 0; i < 10; i++){
			newAuth[i] = (rand() + 3) %  256; 
	}
}


int encrypt(unsigned char* plainText, int plainTextLen, unsigned char* cipherText) {
    int len, ciphertext_len; 
	EVP_CIPHER_CTX *ctx; 
	ctx = EVP_CIPHER_CTX_new();
	EVP_EncryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, (unsigned char *)key, (unsigned char*) iv);
	EVP_CipherUpdate(ctx, cipherText, &len,  plainText, plainTextLen);
    ciphertext_len = len; 
	EVP_CipherFinal(ctx, cipherText + len, &len); 
    ciphertext_len += len;
    EVP_CIPHER_CTX_free(ctx);

 	return ciphertext_len; 
}

int decrypt(unsigned char* cipherText, int cipherTextLen, unsigned char * plainText)  {
	EVP_CIPHER_CTX *ctx;
	int len, plainTextLen;
	ctx = EVP_CIPHER_CTX_new();
    EVP_DecryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, (unsigned char *) key, (unsigned char*)iv);
	EVP_DecryptUpdate(ctx, plainText, &len, cipherText, cipherTextLen);
    plainTextLen = len; 
	EVP_DecryptFinal_ex(ctx, plainText + len, &len);
    plainTextLen += len;
	EVP_CIPHER_CTX_free(ctx);
    return plainTextLen;
}

int  begin_session_send( ATM *atm,  char *username, char *cardLocation, char *pin , int usernameLen) {
	EVP_MD_CTX *mdctx; 
	FILE *card = fopen(cardLocation, "r");
	char cardText[16];
	char plainText[35];
	unsigned char hash[16]; 
	unsigned int hashLen; 
	mdctx = EVP_MD_CTX_new();
	unsigned char cipherText[48];
	
	//char usernameA[usernameLen];
	//sprintf(usern
	if(card == NULL){
		printf("Unable to access %s's card", username); 
		return 1; 
	}

	fread(cardText, 1, 16, card);
	EVP_DigestInit_ex(mdctx, EVP_shake128(), NULL);
	EVP_DigestUpdate(mdctx, cardText, 16); 
	EVP_DigestUpdate(mdctx, username, usernameLen);
	EVP_DigestFinal_ex(mdctx, hash, &hashLen);
    strncpy(plainText, "start", 6);
	///////////////// Needs to be used for the card file ////////////////////////////////
	strncpy(plainText + 5, pin, 4);
	strncpy(plainText + 9, (char *) hash, 16); 
    strncpy(plainText + 25, currSyncKey, 10); 
	encrypt((unsigned char*) plainText, 35, cipherText);
    atm_send(atm, (char* ) cipherText, 48);
	return 0; 
}

int  begin_session(ATM *atm, char * command, char *username){
		//prevent brute force attack
		if (failedAttempts > 10) {
			printf("%s", "to many failed attemts\n");
			return 1; 
		}
		//check if valid username size 
		char * foundName = command + 14; 
		if (strlen(foundName) > 250){
			printf("%s","Username to Long\n"); 
			return 1; 
		}
		//check if all valid characters 
		int i = 0; 
        for( int i; i < strlen(foundName); i++){
			int ch = foundName[i]; 
			if ( ch > 65 && (ch < 91 || (ch > 96 && ch > 123))){
				printf("%s","Not Valid Username\n");
				return 2; 
			}
		}
		username = foundName; 

		// get and validate pin
		char pin[6]; 
		printf("PIN? "); 
		fgets(pin, 6, stdin); 
		if(strlen(pin) != 5) {
			printf("%s", "Pin not valid length\n");
			return 3; 
		} 
		for(i = 0; i < 4; i++){
			char ch = pin[i]; 
			if ( ch < 48  || ch > 57){
				printf("%s", "not a valid pin\n");
				return 4; 
			}
		}		
		char * fileLoc = malloc( sizeof(char) * (sizeof(foundName) + 5));  
		sprintf(fileLoc, "%s.card", username); 
	 	if (begin_session_send(atm, username, fileLoc, pin, strlen(username)) == 1){
			return 9;
		}
		//after recieve response
		char recvCipher[49] ;
		ssize_t rcvSize = atm_recv(atm, recvCipher, 49);
		
		if(rcvSize != 48) {
			printf("%s", "bad response size\n");
			return 5; 
		}
		unsigned char plainText[48]; 
		decrypt((unsigned char*) recvCipher, 48, plainText); 
		printf("%s",  (char *) plainText);

		//verify and authenticate plainText
		if(strncmp("start", (char *) plainText, 5) != 0){
			//REMOVE THIS PRINT BEFORE DONE
			printf("%s", "bad response header"); 
			return 6;
		}
		if(strncmp(currSyncKey, (char *) (plainText + 6), 10) != 0){
			//REMOVE BEFORE DONE
			printf("%s", "bad response auth"); 
			return 7;
		}
		strncpy(currSyncKey, (char *) (plainText + 16), 10); 
		
		if(strncmp("y", (char *) (plainText + 5),  1) != 0){
			printf("%s", "Not authorized"); 
			return 8; 
		}
		
		loggedOn = 1;
		printf("%s", "Authorized");
		return 0; 
}

int request_balance( ATM *atm){
	char plainText[35]; 
	unsigned char cipherText[48];
	strncpy(plainText, "balan", 6); 
    strncpy(plainText + 5, currSyncKey, 10); 
    createAuth((unsigned char *)(plainText + 15));

	//this one is just garbage values to make the cypherText long enough
    createAuth((unsigned char *)(plainText + 25));
    
	encrypt( (unsigned char * ) plainText, 35, cipherText);
	atm_send(atm, (char *) cipherText, 48);

	//after recieve response
	char recvCipher[49] ;
	ssize_t rcvSize = atm_recv(atm, recvCipher, 49);
	
	
	//ensure valid size
	if(rcvSize != 48) {
		printf("%s", "bad response size\n");
		return 1; 
	}

	unsigned char rcvPlainText[48]; 
	decrypt((unsigned char*) recvCipher, 48, rcvPlainText); 
	printf("%s",  (char *) plainText);
    
	if(strncmp("balan", (char *) rcvPlainText, 5) != 0){
		//REMOVE THIS PRINT BEFORE DONE
		printf("%s", "bad response header\n"); 
		return 2;
	}
	//ensure correct authToken
	if(strncmp(currSyncKey, (char *) (rcvPlainText + 15), 10) != 0){
		//REMOVE BEFORE DONE
		printf("%s", "bad response auth\n"); 
		return 3;
		}
	//update auth key
	strncpy(currSyncKey, (char *) (rcvPlainText + 25), 10); 
	
	char balance[11]; 
	strncpy(balance, (char *) (rcvPlainText + 5), 10); 	
	printf("$%s\n", balance); 
	return 0; 
}

int request_withdraw(ATM *atm){


 return 0; 
}
 
int atm_process_command(ATM *atm, char *command, char* username) {
	 
	 if (strncmp("begin-session ", command, 14) == 0 ){
		if(loggedOn == 1){
			printf("%s", "A user is already logged on\n");
       		return 1;
		}
		int result = begin_session(atm, command, username); 
		if (result == 0){
			return 2; 
		}
		else {
			return -1;
		}
	}
	else if (strncmp("balance", command, 7) == 0){
		if(loggedOn == 0){
			 printf("%s", "You are not logged on\n");
			 return 3; 
		}
		int result = request_balance(atm);
		if(result == 0)	{
			return 4;
		}
		else {
			return -1;
		}
		
	}
	else if (strncmp("withdraw", command, 8) == 0){
		if(loggedOn == 0){
			 printf("%s", "You are not logged on\n");
			 return 3; 
		}


	}
	else{
		printf("Invalid command\n"); 

	} 




	return 0;
}
    // TODO: Implement the ATM's side of the ATM-bank protocol

	/*
	 * The following is a toy example that simply sends the
	 * user's command to the bank, receives a message from the
	 * bank, and then prints it to stdout.
	 */


	/*
    char recvline[10000];
    int n;

    atm_send(atm, command, strlen(command));
    n = atm_recv(atm,recvline,10000);
    recvline[n]=0;
    fputs(recvline,stdout);
	*/

